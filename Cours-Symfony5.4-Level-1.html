<html>
<head>
<meta charset="utf-8">
<title>Cours Symfony 5 level 1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="http://cdn.cogitium.com/prism/prism.css">
<style>
* {
    font-family: Verdana;
}
.container {
    width: 80%;
    margin: auto;
}
@media (max-width: 500px) {
    .container {
        width: 100%;
    }
}
</style>
</head>
<body>
<div class="container">
<hr>
<h1>Cours Symfony 5 level 1</h1>
<h2>par Philippe Giraud pour COGITIUM Academy</h2>
<h2>Version du 08 Avril 2022</h2>
<h2>Version de Symfony utilisée : 5.4</h2>
<h2><a href="mailto:academy@cogitium.com">academy@cogitium.com</a></h2>
<hr>
<h2>PLAN DU COURS</h2>
<pre>
<a href="#pre">Présentation générale</a> 
<a href="#ins">Installation de l'environnement de travail</a> 
<a href="#dem">Démarrer un projet Symfony</a> 
<a href="#git">Git : mettre en place le dépôt</a> 
<a href="#rou">Comprendre les routes</a>
<a href="#int">Intégration Frontend</a>
<a href="#pas">Passage de données entre controller et view</a>
<a href="#uti">Gestion des utilisateurs</a>
<a href="#ent">Gestion des entités métier</a>
<a href="#ini">Gestion des valeurs initiales des entités</a>
<a href="#formcat">Création d'un formulaire de création d'une catégorie</a>
<a href="#formpost">Création d'un formulaire de création d'un post</a>
<a href="#cke">Utilisation d'un éditeur WYSIWYG</a>
<a href="#rep">Utiliser le repository pour afficher les données dans les vues</a>
<a href="#par">Le système de param converter</a>
<a href="#sql1">Faire des requêtes SQL grâce à l'entity manager</a>
<a href="#sql2">Faire des requêtes SQL grâce au Query Builder</a>
<a href="#crud">Mise en place d'un CRUD d'administration</a>
<a href="#navbo">Amélioration du layout backoffice</a>
</pre>
<!--**********************************************************-->
<hr>
<h3 id="pre">PRESENTATION GENERALE</h3>
<h4>Le design Pattern MVC</h4>
<a href="https://fr.wikipedia.org/wiki/Mod%C3%A8le-vue-contr%C3%B4leur" target="_blank">Présentation Wikipedia</a>
<h4>Le framework Symfony</h4>
<a href="https://fr.wikipedia.org/wiki/Symfony" target="_blank">Historique Wikipedia</a>
<h4>Rappels de PHP OO et de MVC</h4>
Manipulation en fonction des cours précédents
<!--**********************************************************-->

<!--**********************************************************-->
<hr>
<h3 id="ins">INSTALLATION DE L'ENVIRONNEMENT DE TRAVAIL</h3>
<a href="https://symfony.com/doc/current/setup.html" target="_blank">https://symfony.com/doc/current/setup.html</a>
<!--**********************************************************-->
<p><pre>Installer les logiciels nécessaires :
- CLI Symfony
- Serveur PHP
- Serveur MySQL
- Composer
- Git
- Visual Studio Code avec les extensions :
     + PHP Intelephense
     + PHP Namespace Resolver
     + Twig Language
     * PHPDoc Comment
     * French Language Pack
</pre></p>
<p>Vérifier les versions et procéder aux mises à jour nécessaires</p>

<p>Pour vérifier les pré-requis :</p>
<pre><code class="language-bash">symfony check:requirements</code></pre>

<!--**********************************************************-->
<hr>
<h3 id="dem">DEMARRER UN PROJET SYMFONY</h3>
<!--**********************************************************-->
<p>Pour comprendre les versions de Symfony, <a href="https://symfony.com/releases" target="_blank">cliquez ici</a>.</p>

<p>Créer un nouveau projet complet avec le CLI:</p>

<p>Pour installer la dernière branche maintenue :</p>
<pre><code class="language-bash">symfony new symfony-cours --webapp</code></pre>

<p>Pour installer la version LTS (long-term support) :</p>
<pre><code class="language-bash">symfony new symfony-cours --version=lts --webapp</code></pre>

<p>Pour installer une version spécifique :</p>
<pre><code class="language-bash">symfony new symfony-cours --version=5.4 --webapp</code></pre>

<p>Pour installer la version en cours de développement :</p>
<pre><code class="language-bash">symfony new symfony-cours --version=next --webapp</code></pre>

<p>Pour installer le projet démo (blog avec frontoffice et backoffice avec SQLite) :</p>
<pre><code class="language-bash">symfony new symfony-demo --demo</code></pre>

<p>Se placer dans le dossier du projet, puis lancer le serveur interne de Symfony :</p>
<pre><code class="language-bash">symfony server:start</code></pre>

<p>Consulter le résultat sur l'adresse <a href="https://localhost:8000" target="_blank">https://localhost:8000</a>. 
Une page par défaut s'affiche et indique la version de Symfony</p>

<p>Pour vérifier les détails d'un projet :</p>
<pre><code class="language-bash">php bin/console about</code></pre>

<!--**********************************************************-->
<hr>
<h3 id="git">GIT : METTRE EN PLACE LE DEPOT</h3>  
<!--**********************************************************-->
<p>Vérifier le fonctionnement du dépôt local :</p>
<pre><code class="language-bash">git status</code></pre>

<p>Constater l'absence de remote dans le dépôt :</p>
<pre><code class="language-bash">git remote -v</code></pre>

<p>Créer un dépot sur BitBucket ou GitHub sans Readme ni Gitignore</p>
<p>Ajouter les remote dans le git du projet :</p>
<pre><code class="language-bash">git remote add origin https://xxxxxxxxx@bitbucket.org/yyyyyy/zzzzzzzz.git</code></pre>

<p>Constater la présence de remote dans le dépôt :</p>
<pre><code class="language-bash">git remote -v</code></pre>

<p>Vérifier le nom de la branche par défaut :</p>
<pre><code class="language-bash">git branch</code></pre>

<p>Pusher le dépôt :</p>
<pre><code class="language-bash">git push -u origin main</code></pre>

<!--**********************************************************-->
<hr>
<h3 id="rou">COMPRENDRE LES ROUTES</h3>
<!--**********************************************************-->
<p>Créer un controller avec le Maker :</p>
<pre><code class="language-bash">php bin/console make:controller</code></pre>

<p>Donner un nom au controller : Test</p>

<p>Constater les 2 fichiers créés, un controller et une view, et la route (attribut ou annotation) :</p>
<pre><code class="language-php">#[Route('/test', name: 'app_test')]</code></pre>
<pre><code class="language-php">@Route("/test", name="test")</code></pre>

<p>Tester dans le navigateur  <a href="https://localhost:8000/test" target="_blank">https://localhost:8000/test</a>. 
Constater le message : Hello TestController!</p>

<p>(Si un problème évoque un fichier Json ou parle de Webpack, supprimer le bundle Webpack Encore dans composer.json puis faire un composer update)</p>

<p>Remarque : Un controller n'est pas obligé d'appeler une view, il peut retourner un Json, utile pour les APIs et les fonctionnements asynchrones :</p>
<pre><code class="language-php">
public function index(): Response
{
    /*
    return $this->render('test/index.html.twig', [
        'controller_name' => 'TestController',
    ]);
    */
    return $this->json(['username' => 'jane.doe']);
}
</code></pre>

<p>Regarder le code de la vue afin de constater l'appel au layout</p>

<p>Créer une autre route avec une méthode et un paramètre (attribut ou annotation) :</p>
<pre><code class="language-php">#[Route('/test/{id}', name: 'test_id', methods: ["GET"], requirements: ['id' => '\d+'])]</code></pre>
<pre><code class="language-php">@Route("/test/{id}", name="test_id", methods={"GET"}, requirements={"id"="\d+"})</code></pre>

<p>Pour la liste des méthodes HTTP : 
<a href="https://developer.mozilla.org/fr/docs/Web/HTTP/M%C3%A9thode" target="_blank">https://developer.mozilla.org/fr/docs/Web/HTTP/M%C3%A9thode</a></p>

<p>Et faire une vue identique à la première : test.html.twig</p>
<p>Appeler cette vue depuis le controller</p>

<pre><code class="language-php">
/**
 * @Route("/test/{id}", name="test_id", methods={"GET"}, requirements={"id"="\d+"})
 */
 public function test_id($id): Response
 {
    return $this->render('test/test.html.twig', [
        'controller_name' => 'TestController',
    ]);
 }
</code></pre>

<p>Tester le paramètre reçu avec Dump and Die :</p>

<pre><code class="language-php">
public function test_id($id): Response
{
    dd($id);
    return $this->render('test/test.html.twig', [
        'controller_name' => 'TestController',
    ]);
}
</code></pre>

<p>Transmettre le paramère à la vue :</p>

<pre><code class="language-php">
public function test_id($id): Response
{
    //dd($id);
    return $this->render('test/test.html.twig', [
        'controller_name' => 'TestController',
        'id' => $id,
    ]);
}
</code></pre>

<p>Tester la valeur reçue dans la vue :</p>

<pre><code class="language-html"><textarea>
<div class="example-wrapper">
    <h1>Hello {{ controller_name }}! ✅</h1>
    {{ dump(id) }}
    This friendly message is coming from:
    <ul>
        <li>Your controller at <code><a href="{{ 'C:/wamp64/www/cogitium/bitbucket/symfony5-cours/src/Controller/TestController.php'|file_link(0) }}">src/Controller/TestController.php</a></code></li>
        <li>Your template at <code><a href="{{ 'C:/wamp64/www/cogitium/bitbucket/symfony5-cours/templates/test/index.html.twig'|file_link(0) }}">templates/test/test.html.twig</a></code></li>
    </ul>
</div>
</textarea></code></pre>

<p>Faire des liens dans les vues entre les 2 routes :</p>
<pre><code class="language-html"><textarea>
<a href="{{ path('test') }}">Lien vers test</a>
<a href="{{ path('test_id', {id: 13}) }}">Lien vers test_id</a>
</textarea></code></pre>

<p>Gestion de la priorité des routes :</p>
<p>Les routes sont recherchées dans l'ordre où elles sont définies. Parfois, des conflits peuvent se produire.</p>
<p>Il est possible de définir précisément l'ordre de recherche, avec l'option priority :</p>

<pre><code class="language-php">
    /**
     * @Route("/test/{id}", name="test_id", methods={"GET"}, requirements={"id"="\d+"}, priority=10)
     */
    public function test_id($id): Response
    {
        return ...
    }
</code></pre>

<p>Plus la valeur est grande, plus la route est prioritaire donc cherchée tôt.</p>

<!--**********************************************************-->
<hr>
<h3 id="int">INTEGRATION FRONTEND</h3>
<!--**********************************************************-->
<p>Partir d'un template et l'intégrer dans le layout</p>
<p><a href="https://startbootstrap.com/theme/clean-blog" target="_blank">https://startbootstrap.com/theme/clean-blog</a></p> 

<p><pre>Faire une copie de base.html.twig en clean.html.twig 
et intégrer le layout :
Header : intégrer le Title, css, js_top
Footer : intégrer js_bottom</pre></p>

<p><pre>Puis créer un controller Post avec les routes :
 /           : home
 /post/{$id} : post_view</pre></p>

<p>Dans les vues correspondantes, intégrer les pages index.html et post.html</p>

<p><pre>Ajouter les routes :
 /about      : page_about
 /contact    : page_contact</pre></p>

<p>Dans les vues correspondantes, intégrer les pages about.htm et contact.html</p>

<p>Tester les différentes routes</p>

<p>Intégrer les ressources statiques dans le dossier public, dans un sous-dossier clean</p>

<p>Présenter l'intérêt de la fonction asset() avec un css perso et une route à 2 niveaux</p>

<p>Puis mettre à jour les Urls dans le layout :</p>
<pre><code class="language-bash"><textarea>
    <!-- Bootstrap core CSS -->
    <link href="{{ asset('clean/vendor/bootstrap/css/bootstrap.min.css') }}" rel="stylesheet">

    <!-- Custom fonts for this template -->
    <link href="{{ asset('clean/vendor/fontawesome-free/css/all.min.css') }}" rel="stylesheet" type="text/css">

</textarea></code></pre>

<p>Mettre en place les liens de navigation sur les routes souhaitées</p>

<p>Exemple : </p>
<pre><code class="language-bash"><textarea>
<a class="navbar-brand" href="{{ path('home') }}">My Symfony Blog</a>
</textarea></code></pre>

<!--**********************************************************-->
<hr>
<h3 id="pas">PASSAGE DE DONNEES ENTRE CONTROLLER ET VIEW</h3>
<!--**********************************************************-->
<p>Pour comprendre le passage de données, depuis le controller post/view, 
envoyer un objet avec un titre et un contenu :</p>
<pre><code class="language-php">
    return $this->render('post/post.html.twig', [
        'post' => [
            'title' => 'Le titre',
            'content' => 'Le super contenu'
        ],
    ]);
</code></pre>

<p>Puis utiliser ces données dans la vue correspondante :</p>

<pre><code class="language-html"><textarea>
    <h1>{{ post.title }}</h1>

    <p>{{ post.content }}</p>
</textarea></code></pre>

<!--**********************************************************-->
<hr>
<h3 id="uti">GESTION DES UTILISATEURS</h3>
<!--**********************************************************-->
<p>Début de la construction de la base de données, avec une entitée principale pour gérer les utilisateurs.</p>

<p><pre>Nous allons utiliser des mécanismes proposés par Symfony pour :
- Proposer à un utilisateur de s'enregistrer
- Confirmer son inscription
- Réinitialiser son mot de passe

Pour cela, nous allons utiliser :
- La base de données et donc l'ORM Doctrine
- L'envoi de mail et donc un SMTP</pre></p>

<p>Commençons par configurer ces 2 mécanismes. Editer le fichier .env à la racine du projet :</p>

<pre><code class="language-php">
    ###> symfony/mailer ###
    MAILER_DSN=smtp://localhost:1025
    ###< symfony/mailer ###

    ###> doctrine/doctrine-bundle ###
    # Format described at https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/configuration.html#connecting-using-a-url
    # IMPORTANT: You MUST configure your server version, either here or in config/packages/doctrine.yaml
    #
    # DATABASE_URL="sqlite:///%kernel.project_dir%/var/data.db"
    DATABASE_URL="mysql://root:@127.0.0.1:3306/symfony5_cours?serverVersion=5.7"
    # DATABASE_URL="postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=13&charset=utf8"
    ###< doctrine/doctrine-bundle ###
</code></pre>

<p>Pour utiliser MariaDB il faut préciser :</p>
<pre><code class="language-php">
    DATABASE_URL="mysql://root:@127.0.0.1:3306/symfony5_cours?serverVersion=10.4.17-MariaDB"
</code></pre>

<p>Il faut maintenant créer la base de données physique telle que définie dans la config :</p>
<pre><code class="language-bash">php bin/console doctrine:database:create</code></pre>

<p>Constater dans PhpMyAdmin la création effective.</p>

<p>Nous pouvons utiliser le Maker de Symfony pour générer beaucoup de choses, notament pour la gestion utilisateur. Regarder les options de la commande make :</p>
<pre><code class="language-bash">php bin/console make</code></pre>

<p>Nous pouvons maintenant créer la première entité de la BD qui sera User :</p>
<pre><code class="language-bash">php bin/console make:user</code></pre>

<p>Ici le mot "user" ne préjuge pas du futur nom de l'entité.</p>

<p>Les valeurs : User, Yes, email, Yes.</p>

<p>Constater les fichiers créés.</p>

<p><b>ATTENTION : </b>en version 5.3 il y a des dépréciations. A la date du mois de Juin 2021 en version, il faut modifier l'entité User :</p>
<pre><code class="language-php">/**
* A visual identifier that represents this user.
*
* @see UserInterface
*/
//public function getUserIdentifier(): string
public function getUsername(): string
{
   return (string) $this->email;
}
</code></pre>

<p>On a une nouvelle entité, on peut la persister dans la BD. Créer une migration :</p>
<pre><code class="language-bash">php bin/console make:migration</code></pre>

<p>Constater le contenu du fichier.</p>

<p>Envoyer la migration sur la BD :</p>
<pre><code class="language-bash">php bin/console doctrine:migrations:migrate</code></pre>

<p>Constater la table dans la BD et la table des migrations.</p>

<p>Création du système d'authentification :</p>
<pre><code class="language-bash">php bin/console make:auth</code></pre>

<p>Les valeurs : 1, UserAuthenticator, SecurityController, Yes.</p>

<p>Remarquer le TODO dans la console.</p>

<p>Modifier le fichier App\Security\UserAuthenticator :</p>
<pre><code class="language-php">
    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $providerKey)
    {
        if ($targetPath = $this->getTargetPath($request->getSession(), $providerKey)) {
            return new RedirectResponse($targetPath);
        }

        return new RedirectResponse($this->urlGenerator->generate('home'));
        //throw new \Exception('TODO: provide a valid redirect inside '.__FILE__);
    }
</code></pre>

<p>Création de l'inscription utilisateur :</p>
<pre><code class="language-bash">php bin/console make:registration-form</code></pre>

<p>Les valeurs : yes, yes, no, no-reply@company.com, company.com, yes.</p>

<p>Remarquer le message sur le bundle manquant et les modif à faire :</p>
<pre><code class="language-bash">composer require symfonycasts/verify-email-bundle</code></pre>

<p>Puis modifier la route dans RegistrationController :</p>
<pre><code class="language-php">
    /**
     * @Route("/verify/email", name="app_verify_email")
     */
    public function verifyUserEmail(Request $request): Response
    {
        $this->denyAccessUnlessGranted('IS_AUTHENTICATED_FULLY');

        // validate email confirmation link, sets User::isVerified=true and persists
        try {
            $this->emailVerifier->handleEmailConfirmation($request, $this->getUser());
        } catch (VerifyEmailExceptionInterface $exception) {
            $this->addFlash('verify_email_error', $exception->getReason());

            return $this->redirectToRoute('app_register');
        }

        // @TODO Change the redirect on success and handle or remove the flash message in your templates
        $this->addFlash('success', 'Your email address has been verified.');

        return $this->redirectToRoute('home');
    }
</code></pre>

<p>Afficher les messages flash dans le layout. Il y a un modèle dans register.html.twig :</p>
<pre><code class="language-html"><textarea>
    {% for message in app.flashes('success') %}
        <div class="alert alert-success" role="alert">{{ message }}</div>
    {% endfor %}
</textarea></code></pre>

<p>Faire la migration :</p>
<pre><code class="language-bash">php bin/console make:migration</code></pre>

<p>Puis :</p>
<pre><code class="language-bash">php bin/console doctrine:migrations:migrate</code></pre>

<p>Constater dans la BD.</p>

<p>Tester l'inscription sur <a href="https://localhost:8000/register" target="_blank">https://localhost:8000/register</a></p>

<p><pre>A partir du moment où le register va envoyer un mail de confirmation, il faut deux outils :
- Un serveur SMTP
- Une boite mail
</pre></p>

<p><pre>Il existe plusiers outils qui font cela, entre autre ces deux là :<br>
- Maildev : un outils qui fonctionne avec NodeJS
    Installation :  <a href="https://github.com/maildev/maildev" target="_blank">https://github.com/maildev/maildev</a>
    ATTENTION : pour tester avec Maildev, il faut le lancer avec l'otion --hide-extensions STARTTLS

- MailHog : une application qui fonctionne sur beaucoup de systèmes
     Installation :  <a href="https://github.com/mailhog/MailHog/blob/master/docs/RELEASES.md" target="_blank">https://github.com/mailhog/MailHog/blob/master/docs/RELEASES.md</a>
</pre></p>


<p><pre>
Constater le mail et le user dans le profiler
Confirmer en cliquant sur le lien dans le mail
Constater la redirection vers home
Constater dans PhpMyAdmin
Tester /logout
Tester /login
</pre></p>

<p>Ajouter la réinitialisation du password :</p>
<pre><code class="language-bash">php bin/console make:reset-password</code></pre>

<p>Constater le message qui demande un bundle :</p>
<pre><code class="language-bash">composer require symfonycasts/reset-password-bundle</code></pre>

<p>Relancer le make :</p>
<pre><code class="language-bash">php bin/console make:reset-password</code></pre>

<p>Les valeurs : app_login, no-reply@company.com, company.com</p>

<p>Remarquer les notes.</p>

<p>Faire la migration et l'appliquer.</p>

<p>Tester la route <a href="https://localhost:8000/reset-password" target="_blank">https://localhost:8000/reset-password</a></p>

<p>Pour y accèder, mettre un lien dans le form de login.</p>

<h4>Intégration frontend des mécanismes user</h4>

<p>Dans le menu du layout :</p>
<pre><code class="language-bash"><textarea>
    {% if not is_granted("ROLE_USER") %}
        <li class="nav-item">
            <a class="nav-link" href="{{ path('app_register') }}">S'inscrire</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{{ path('app_login') }}">Login</a>
        </li>
    {% else %}
        <li class="nav-item">
            <a class="nav-link" href="{{ path('app_logout') }}">Logout</a>
        </li>
    {% endif %}
</textarea></code></pre>

<p>De façon générale pour les formulaires, appliquer le thème Bootstrap dans le fichier config/packages/twig.yaml :</p>
<pre><code class="language-bash">
twig:
    default_path: '%kernel.project_dir%/templates'
    form_themes: ['bootstrap_5_layout.html.twig']
</code></pre>

<p>Pour voir les différents thèmes possibles, <a href="https://symfony.com/doc/current/form/form_themes.html" target="_blank">cliquez ici</a>.</p>

<p>Dans les différentes pages (register, login, request), ajouter un peu de structure bootstrap et supprimer l'affichage du flash dans register.</p>

<!--**********************************************************-->
<hr>
<h3 id="ent">GESTION DES ENTITES METIER</h3>
<!--**********************************************************-->
<p>Nous devons gérer des articles (Post) rangés dans des catégories (Category). Ces catégories seront hiérarchiques.</p>

<p>Créer l'entité Category :</p>
<pre><code class="language-bash">php bin/console make:entity Category</code></pre>

<p><pre>Les valeurs :
- name, string, 100, no
- slug, string, 120, no
- parent, relation, Category, ManyToOne, yes, yes, categories
</pre></p>

<p>Faire la migration et l'intégrer.</p>

<p>Créer l'entité Post :</p>
<pre><code class="language-bash">php bin/console make:entity Post</code></pre>

<p><pre>Les valeurs :
- title, string, 255, no
- slug, string, 255, no
- content, text, no
- image, string, 255, no
- createdAt, datetime, no
- active, boolean, no
- user, relation, User, ManyToOne, no, yes, posts, yes
- category, relation, Category, ManyToOne, no, yes, posts, no
</pre></p>

<p>Faire la migration et l'intégrer.</p>

<!--**********************************************************-->
<hr>
<h3 id="ini">GESTION DES VALEURS INITIALES DES ENTITES</h3>
<!--**********************************************************-->
<p><pre>Dans cette partie nous allons voir comment gérer l'initialisation de certaines valeurs lors de la création des enregistrements :
- createdAt : datetime de création
- slug : la transformation slug du nom de la catégorie ou du titre de l'article
afin de l'utiliser dans les URLs (SEO).
</pre></p>

<p>Pour gérer cela facilement au niveau des annotations, installer l'extension :</p>
<pre><code class="language-bash">composer require antishov/doctrine-extensions-bundle</code></pre>

<p>Ce n'est pas un package officiel de Symfony, donc il y a une confirmation.</p>

<p>Mettre à jour le fichier config/packages/stof_doctrine_extensions.yaml :</p>
<pre><code class="language-yaml">
    stof_doctrine_extensions:
        default_locale: fr_FR
        orm:
            default:
                sluggable: true
</code></pre>

<p>Dans l'entité Category, on ajoute le Use :</p>
<pre><code class="language-php">use Gedmo\Mapping\Annotation as Gedmo;</code></pre>

<p>Puis au niveau de la propriété slug :</p>
<pre><code class="language-php">
    /**
     * @gedmo\Slug(fields={"name"})
     * @ORM\Column(type="string", length=120)
     */
     private $slug;

    ou en attribut :
    #[Gedmo\Slug(fields: ['name'])]
</code></pre>

<p>On peut supprimer le setter de slug puisqu'il ne sera pas nécessaire.</p>

<!--**********************************************************-->
<hr>
<h3 id="formcat">CREATION D'UN FORMULAIRE DE CREATION D'UNE CATEGORIE</h3>
<!--**********************************************************-->
<p>Il faut créer un formulaire afin de pouvoir créer des catégories. Pour cela, il faut appeler le maker pour créer en premier un controller :</p>
<pre><code class="language-bash">php bin/console make:controller AdminController</code></pre>

<p>Puis un formulaire :</p>
<pre><code class="language-bash">php bin/console make:form CategoryType</code></pre>

<p>L'associer à l'entité Category.</p>

<p>Constater le controller et le formulaire.</p>

<p>Personnaliser le formulaire :</p>
<pre><code class="language-php">
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            ->add('name', TextType::class)
            /*->add('slug')*/
            /*->add('parent')*/
            ->add('Valider', SubmitType::class)
        ;
    }
</code></pre>

<p>Ne pas oublier les use !</p>

<p>Pour personnaliser les labels :</p>
<pre><code class="language-php">
    ->add('name', TextType::class, [
        "label" => "Nom de la catégorie",
    ])
</code></pre>

<p>Dans le controller, paramétrer les routes. Toutes les pages d'administration seront dans la route /admin et les names commencerons par admin_ :</p>
<pre><code class="language-php">
    /**
    * @Route("/admin", name="admin_")
    */
   class AdminController extends AbstractController
   {
       /**
        * @Route("/", name="home")
        */
       public function index(): Response
       {
           return $this->render('admin/index.html.twig', [
               'controller_name' => 'AdminController',
           ]);
       }
   }
</code></pre>

<p>Créer une autre route :</p>
<pre><code class="language-php">
    /**
     * @Route("/category/add", name="category_add")
     */
    public function addCategory(): Response
    {
        return $this->render('admin/index.html.twig', [
            'controller_name' => 'AdminController',
        ]);
    }
</code></pre>

<p>Pour recevoir les données du form, il faut l'objet Request que l'on récupère par l'injection de dépendance.</p>

<p>Puis on instancie une nouvelle category.</p>

<p>Puis on crée le form en lui passant l'instance vide.</p>

<p>On appelle une vue et on lui passe le form transformé en html :</p>
<pre><code class="language-php">
    public function addCategory(Request $request): Response
    {
        $category = new Category();
        $form = $this->createForm(CategoryType::class, $category);

        return $this->render('admin/category/add.html.twig', [
            'form' => $form->createView(),
        ]);
    }
</code></pre>

<p>Créer la vue avec le nom et chemin choisis :</p>
<pre><code class="language-bash"><textarea disabled>
    {% extends 'base.html.twig' %}

    {% block title %}Ajout d'une catégorie{% endblock %}
    
    {% block body %}
        <h1>Ajout d'une catégorie</h1>
        {{ form(form) }}
    {% endblock %}
</textarea></code></pre>

<p>Tester l'affichage du formulaire sur <a href="https://localhost:8000/admin/category/add" target="_blank">https://localhost:8000/admin/category/add</a></p>

<p><pre>Il faut maintenant traiter les données en provenance du formulaire
Pour cela il faut :
- Hydrater l'instance avec les données du form récupérées de la requête
- Tester la soumission du form (POST) et la validité des données du form
- Récupérer l'entity Manager (ORM)
- Persister les données (INSERT)
- Valider la transaction (COMMIT)
- Rediriger sur l'accueil de l'admin :</pre></p>
<pre><code class="language-php">
    $form->handleRequest($request);
    if ($form->isSubmitted() && $form->isValid()) {
        $em = $this->getDoctrine()->getManager();
        $em->persist($category);
        $em->flush();
        return $this->redirectToRoute('admin_home');
    }
</code></pre>

<p>Tester l'ajout d'une catégorie, la redirection et constater les données dans la BD.</p>

<p>Tester avec un nom de catégorie complexe, vérifier le slug.</p>

<!--**********************************************************-->
<hr>
<h3 id="formpost">CREATION D'UN FORMULAIRE DE CREATION D'UN POST</h3>
<!--**********************************************************-->
<p>Reproduire la même chose sur Post avec le slug basé sur title, enlever le setter.</p>

<p>Mais sur Post, il faut aussi initialiser la date de création.</p>

<p>Mettre à jour le fichier config/packages/stof_doctrine_extensions.yaml :</p>
<pre><code class="language-yaml">
    default:
        sluggable: true
        timestampable: true
</code></pre>

<p>Ajouter l'annotation pour créer le timestamp :</p>
<pre><code class="language-php">
    /**
     * @Gedmo\Timestampable(on="create")
     * @ORM\Column(type="datetime")
     */
</code></pre>

<p>Et supprimer le setter correspondant.</p>

<p>Créer un form sur Post :</p>
<pre><code class="language-bash">php bin/console make:form PostType</code></pre>

<p>Personnaliser le form généré :</p>
<pre><code class="language-php">
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            ->add('title', TextType::class)
            /*->add('slug')*/
            ->add('content', TextareaType::class)
            ->add('image', TextType::class)
            /*->add('createdAt')*/
            /*->add('active')*/
            /*->add('user')*/
            ->add('category', EntityType::class, [
                'class' => Category::class
            ])
            ->add('Valider', SubmitType::class)
        ;
    }
</code></pre>

<p>Ajouter une route dans le controller post avec un code similaire à l'ajout de category :</p>
<pre><code class="language-php">
    /**
     * @Route("/post/add", name="post_add")
     */
    public function addPost(Request $request): Response
    {
        $post = new Post();
        $form = $this->createForm(PostType::class, $post);

        return $this->render('post/add.html.twig', [
            'form' => $form->createView(),
        ]);
    }
</code></pre>

<p>Puis une vue :</p>
<pre><code class="language-html"><textarea>
    {% extends 'clean.html.twig' %}

    {% block title %}Ajout d'un article{% endblock %}
    
    {% block body %}
            <!-- Page Header -->
            <header class="masthead" style="background-image: url('{{ asset('clean/img/home-bg.jpg') }}')">
                <div class="overlay"></div>
                <div class="container">
                    <div class="row">
                        <div class="col-lg-8 col-md-10 mx-auto">
                            <div class="site-heading">
                                <h1>Clean Blog</h1>
                                <span class="subheading">A Blog Theme by Start Bootstrap</span>
                            </div>
                        </div>
                    </div>
                </div>
            </header>
            <!-- Main Content -->
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <h1>Ajout d'un article</h1>
                        {{ form(form) }}
                    </div>
                </div>
            </div>
    {% endblock %}
</textarea></code></pre>

<p>Lors du test, une erreur apparait :</p>
<pre><code class="language-bash">Object of class App\Entity\Category could not be converted to string</code></pre>

<p>La liste déroulante prévue pour lister les catégories ne sait pas qu'elle colonne prendre comme "string". Il faut ajouter une méthode dans l'entité pour la fournir :</p>
<pre><code class="language-php">
    public function __toString()
    {
        return $this->name;
    }
</code></pre>

<p>Vérifier que le form s'affiche correctement et que la liste est remplie.</p>

<p><pre>Maintenant il faut traiter le form :
- Associer l'utilisateur connecté
- Mettre l'indicateur Active à false (pourrait être initialisé dans l'entité)
- Puis faire comme Category pour traiter la persistance</pre></p>
<pre><code class="language-php">
    if ($form->isSubmitted() && $form->isValid()) {
        $post->setUser($this->getUser());
        $post->setActive(false);
        $em = $this->getDoctrine()->getManager();
        $em->persist($post);
        $em->flush();
        return $this->redirectToRoute('home');
    }
</code></pre>

<p>Tester après avoir identifié un user.</p>

<p>ATTENTION : pour les urls d'images, prendre uniquement des adresses HTTPS !!!!</p>

<p>Vérifier dans la BD la création de l'article, le slug, la date de création, les clés étrangères.</p>

<!--**********************************************************-->
<hr>
<h3 id="cke">UTILISATION D'UN EDITEUR WYSIWYG</h3>
<a href="https://symfony.com/doc/current/bundles/FOSCKEditorBundle/installation.html" target="_blank">https://symfony.com/doc/current/bundles/FOSCKEditorBundle/installation.html</a>
<!--**********************************************************-->
<p>Télécharger CKEditor :</p>
<pre><code class="language-bash">composer require friendsofsymfony/ckeditor-bundle</code></pre>

<p>Puis l'installer :</p>
<pre><code class="language-bash">php bin/console ckeditor:install</code></pre>

<p>Puis installer les assets de CKEditor :</p>
<pre><code class="language-bash">php bin/console assets:install public</code></pre>

<p>Configurer l'éditeur dans le fichier config/packages/fos_ckeditor.yaml :</p>
<pre><code class="language-yaml">
twig:
    form_themes:
        - '@FOSCKEditor/Form/ckeditor_widget.html.twig'
fos_ck_editor:
    configs:
        main_config:
            toolbar:
                - { 
                    name: "styles", 
                    items: ['Bold', 'Italic', 'Underline', 'Strike', 'Blockquote', '-', 'Link', '-', 'RemoveFormat', '-', 'NumberedList', 'BulletedList', '-', 'Outdent', 'Indent', '-', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock', '-', 'Image', 'Table', '-', 'Styles', 'Format','Font','FontSize', '-', 'TextColor', 'BGColor', 'Source'] 
                }
</code></pre>

<p>Modifier dans le form Post :</p>
<pre><code class="language-php">
    /*->add('content', TextareaType::class, [*/
    ->add('content', CKEditorType::class, [
        "label" => "Contenu",
    ])
</code></pre>

<p>Tester en créant un article en copiant du texte formaté.</p>

<p>Vérifier dans la BD.</p>

<p>Ajouter un menu quand l'utilisateur est connecté :</p>
<pre><code class="language-html"><textarea>
{% if not is_granted("ROLE_USER") %}
<li class="nav-item">
    <a class="nav-link" href="{{ path('app_register') }}">S'inscrire</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="{{ path('app_login') }}">Login</a>
</li>
{% else %}
<li class="nav-item">
    <a class="nav-link" href="{{ path('post_add') }}">Proposer un article</a>
</li>
<li class="nav-item">
    <a class="nav-link" href="{{ path('app_logout') }}">Logout</a>
</li>
{% endif %}
</textarea></code></pre>

<!--**********************************************************-->
<hr>
<h3 id="rep">UTILISER LE REPOSITORY POUR AFFICHER DES DONNEES DANS LES VUES</h3>
<!--**********************************************************-->
<p>Les données sont dans la BD. Le repository permet, en utilsant l'ORM Doctrine, d'accèder à ces données. Des requêtes génériques sont déjà présentes. Il est donc possible d'aller chercher des données sans écrire de requête.</p>

<p>Dans la page d'accueil, il nous faut tous les posts.</p>

<p>Regarder dans le PostRepository :</p>
<pre><code class="language-php">
    /**
    * @method Post|null find($id, $lockMode = null, $lockVersion = null)
    * @method Post|null findOneBy(array $criteria, array $orderBy = null)
    * @method Post[]    findAll()
    * @method Post[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
    */
</code></pre>

<p>La méthode findAll() renvoie l'ensemble des enregistrements dans un tableau.</p>

<p>Dans le controller Post/index, ajouter un dump des données :</p>
<pre><code class="language-php">
    public function index(PostRepository $postRepository): Response
    {
        $posts = $postRepository->findAll();
        dd($posts);
</code></pre>

<p>Afficher la page et constater les différents enregistrements.</p>

<p>On peut maintenant transmettre ce tableau à la vue (et donc à Twig) :</p>
<pre><code class="language-php">
    public function index(PostRepository $postRepository): Response
    {
        $posts = $postRepository->findAll();
        //dd($posts);

        return $this->render('post/index.html.twig', [
            'posts' => $posts,
        ]);
    }
</code></pre>

<p>Ajouter dans la vue le dump de Twig pour afficher les données reçues :</p>
<pre><code class="language-html"><textarea>
    {% block body %}
    {{ dump(posts) }}
    <!-- Page Header -->
</textarea></code></pre>

<p>On peut maintenant utiliser ces données pour les afficher au milieu du Html. Dans le Html on ne garde qu'un article, puis on fait une boucle pour itérer sur chaque enregistrement :</p>
<pre><code class="language-html"><textarea>
    {% for post in posts %}

        <div class="post-preview">
            <a href="{{ path('post_view', {id: 1}) }}">
                <h2 class="post-title">{{ post.title }}</h2>
                <img src="{{ post.image }}" alt="" style="width: 100%">
                <h3 class="post-subtitle">{{ post.content }}</h3>
            </a>
            <p class="post-meta">Posted by
                <a href="#">Start Bootstrap</a>
                on September 24, 2019</p>
        </div>
        <hr>
                
    {% endfor %}
</textarea></code></pre>

<p><pre>Constater l'affichage des articles
Il y a quelques points à améliorer :
1 - le texte est trop long, il devrait être tronqué
2 - le texte qui contient du html grâce à CKEditor ne s'affiche pas bien, les balises sont visibles
3 - il reste a afficher les informations de date et d'auteur
4 - il n'y a pas la catégorie
5 - le lien envoie un identifiant en dur
</pre></p>

<p>1 = avec le filtre "u.truncate" de Twig, on va tronquer le texte. Mais d'abord il faut installer :</p>
<pre><code class="language-bash">composer require twig/string-extra</code></pre>

<p>Puis pour tronquer le contenu :</p>
<pre><code class="language-html">post.content | u.truncate(150, '...')</code></pre>

<p>2 = avec le filtre "raw" de Twig, on va afficher le texte :</p>
<pre><code class="language-html">post.content | u.truncate(150, '...') | raw</code></pre>

<p>3 = l'auteur est accessible par :</p>
<pre><code class="language-html">post.user.email</code></pre>

<p>La date est affichable par :</p>
<pre><code class="language-html">createdAt | date</code></pre>

<p>Il est préférable d'installer un bundle qui offre différentes possibilités :</p>
<pre><code class="language-bash">composer require knplabs/knp-time-bundle</code></pre>

<p>On peut par exemple utiliser le filtre ago :</p>
<pre><code class="language-html">createdAt | ago</code></pre>

<p>Mais cela affiche en anglais. Il faut installer la traduction :</p>
<pre><code class="language-bash">>composer require symfony/translation</code></pre>

<p>Puis modifier dans config/packages/translation.yaml :</p>
<pre><code class="language-yaml">
framework:
    default_locale: fr
</code></pre>

<p>4 = la catégorie est accessible par post.category.name</p>

<p>5 = dans l'url de la route, il faut remplacer la valeur de id en dur par post.id</p>

<P>Cela doit donner un code comme celui-ci :</P>
<pre><code class="language-HTML"><textarea>
    {% for post in posts %}

        <div class="post-preview">
            <a href="{{ path('post_view', {id: post.id}) }}">
                <h2 class="post-title">{{ post.title }}</h2>
                <h3 class="post-subtitle">{{ post.content | u.truncate(150, "...") | raw }}</h3>
            </a>
            <p class="post-meta">
                Ecrit par {{ post.user.email }} {{ post.createdAt | ago}} - Classé dans {{ post.category.name }}
            </p>
        </div>
        <hr>

    {% endfor %}
</textarea></code></pre>

<!--**********************************************************-->
<hr>
<h3 id="par">LE SYSTEME DE PARAM CONVERTER</h3>
<!--**********************************************************-->
<p>La page de liste des posts appelle la page de détail d'un post en lui transmettant l'Id.</p>

<p>En typant le paramètre en entrée de la méthode, Symfony peut faire la conversion de paramètre afin de retrouver l'instance correspondante.</p>

<p>Il n'y a rien d'autre à faire, c'est le "Param Converter" :</p>
<pre><code class="language-php">
    /**
     * @Route("/post/{id}", name="post_view", methods={"GET"}, requirements={"id"="\d+"})
     */
    public function post(Post $post): Response
    {
        dd($post);
</code></pre>

<p>Constater l'affichage des données de l'article.</p>

<p>Et ce qui fonctionne avec l'Id fonctionne aussi avec le Slug.</p>

<p>Modifier la route et la vue qui génère le lien :</p>
<pre><code class="language-php">
    /**
     * ---Route("/post/{id}", name="post_view", methods={"GET"}, requirements={"id"="\d+"})
     * @Route("/post/{slug}", name="post_view", methods={"GET"})
     */
    public function post(Post $post): Response
</code></pre>

<pre><code class="language-html"><textarea>
    {% for post in posts %}

    <div class="post-preview">
        <a href="{{ path('post_view', {slug: post.slug}) }}">
</textarea></code></pre>

<p>Constater le dump, puis envoyer l'objet à la vue :</p>
<pre><code class="language-php">
    public function post(Post $post): Response
    {
        //dd($post);
        return $this->render('post/post.html.twig', [
            'post' => $post
        ]);
    }
</code></pre>

<p>Comme on avait simulé le title et le content, ils devraient s'afficher dans la vue après avoir enlevé le dump.</p>

<p>Avec les principes déjà vus, il est possible d'améliorer cette page.</p>

<!--**********************************************************-->
<hr>
<h3 id="sql1">FAIRE DES REQUETES SQL GRACE A L'ENTITY MANAGER</h3>
<a href="https://symfony.com/doc/current/doctrine.html#querying-for-objects-the-repository">https://symfony.com/doc/current/doctrine.html#querying-for-objects-the-repository</a>
<!--**********************************************************-->
<p>Pour l'instant nous avons utilisé une requête générique proposée par le repository.</p>

<p>Mais il est possible de définir des requêtes spécifiques directement en SQL.</p>

<p>faut utiliser cette technique si la requête est figée, donc si elle n'accepte pas de paramètres externes.</p>

<p>Dans les autres cas, il faut passer par le Query Builder qui va gérer les paramètres et sécuriser les injections SQL.</p>

<p><pre>Par exemple, nous pouvons faire une requête afin d'être plus précis sur les articles affichés dans la page d'accueil.
Nous allons demander :
- juste les colonnes nécessaires
- juste les posts avec le statut active à true
- les article triés par ordre chronologique
- seulement les 5 derniers articles (sauf nombre précisé)</pre></p>

<p>Ajouter une fonction dans le repository Post :</p>
<pre><code class="language-php">
    public function findOldPosts(int $nb = 5): array
    {
        $entityManager = $this->getEntityManager();

        $query = $entityManager->createQuery(
            'SELECT p.slug, p.title, p.createdAt
            FROM App\Entity\Post p
            WHERE p.active = :status
            ORDER BY p.createdAt ASC'
        )
        ->setParameter('status', true)
        ->setMaxResults($nb)
        ;
        return $query->getResult();
    }
</code></pre>

<p>Utiliser une route de test afin de constater le resultat de cette requête.</p>

<p>Cette fonction pourrait servir à remplir une sidebar avec les plus anciens articles.</p>

<p>Un exemple de sidebar :</p>
<pre><code class="language-html"><textarea>
            <!-- Sidebar -->
            <div class="col-lg-4 col-md-4 mx-auto">
                <h2>Les anciens articles</h2>
                
                {% for oldPost in oldPosts %}
                    <div class="post-preview">
                        <a href="{{ path('post_view', {slug: oldPost.slug}) }}">
                            <h2 class="post-subtitle">{{ oldPost.title }}</h2>
                        </a>
                        <p class="post-meta">{{ oldPost.createdAt | ago }}</p>
                    </div>
                {% endfor %}

            </div>
</textarea></code></pre>

<!--**********************************************************-->
<hr>
<h3 id="sql2">FAIRE DES REQUETES SQL GRACE AU QUERY BUILDER</h3>
<a href="https://symfony.com/doc/current/doctrine.html#querying-with-the-query-builder">https://symfony.com/doc/current/doctrine.html#querying-with-the-query-builder</a>
<a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/query-builder.html">https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/query-builder.html</a>
<!--**********************************************************-->
<p>Le Query Builder est un mécanisme objet proposé par l'ORM Doctrine. C'est le mécanisme à privilégier lors des requêtes dynamiques car la sécurité est assurée par l'ORM.</p>

<p><pre>Nous allons écrire une requête plus précise pour la page d'accueil pour :
- ne garder que les articles avec active à true
- trier les articles par ordre chronologique inverse
- seulement les 5 derniers articles (sauf nombre précisé)</pre></p>

<p>Dans le repository :</p>
<pre><code class="language-php">
    public function findLastPosts(int $nb = 5)
    {
        return $this->createQueryBuilder('p')
            ->andWhere('p.active = :active')
            ->setParameter('active', true)
            ->orderBy('p.createdAt', 'DESC')
            ->setMaxResults($nb)
            ->getQuery()
            ->getResult()
        ;
    }
</code></pre>

<p>Dans le controller :</p>
<pre><code class="language-php">
    public function index(PostRepository $postRepository): Response
    {
        //$posts = $postRepository->findAll();
        $posts = $postRepository->findLastPosts();
        //dd($posts);
        $oldPosts = $postRepository->findOldPosts();
        //dd($oldPosts);
</code></pre>

<!--**********************************************************-->
<hr>
<h3 id="crud">MISE EN PLACE D'UN CRUD D'ADMINISTRATION</h3>
<!--**********************************************************-->
<p><pre>Pour l'instant, nous avons juste dans un controller Admin avec :
- une page d'accueil vide : <a href="https://localhost:8000/admin/">https://localhost:8000/admin/</a>
- la possibilité de créer des catégories : <a href="https://localhost:8000/category/add">https://localhost:8000/admin/category/add</a>
</pre></p>

<p>Allons plus loin en créant un module d'administration un peu plus complet.</p>

<p><pre>Commençons par réorganiser notre AdminController :
- Créer un dossier Controller/Admin
- Déplacer AdminController dedans
</pre></p>

<p>Il faut mettre à jour le Namespace :</p>
<pre><code class="language-php">
    namespace App\Controller\Admin;
</code></pre>

<p>Nous avons des utilisateurs dans la BD. Pour l'instant ils n'ont pas de Role, donc ils sont juste "ROLE_USER" comme l'indique le getter de l'entité :</p>
<pre><code class="language-php">
    public function getRoles(): array
    {
        $roles = $this->roles;
        // guarantee every user at least has ROLE_USER
        $roles[] = 'ROLE_USER';

        return array_unique($roles);
    }
</code></pre>

<p>Sur un des users, mettre le rôle administrateur : ["ROLE_ADMIN"].</p>

<p>Pour protéger l'accès à l'admin, aller dans config/packages/security.yaml. Dans access_control, enlever le commentaire. Il est possible de changer la route :</p>
<pre><code class="language-yaml">
    # Easy way to control access for large sections of your site
    # Note: Only the *first* access control that matches will be used
    access_control:
        - { path: ^/admin, roles: ROLE_ADMIN }
        # - { path: ^/profile, roles: ROLE_USER }
</code></pre>

<p><pre>Vérifier que :
- la redirection vers login se fait quand on est pas identifié
- l'accès est refusé quand on est pas admin
- l'accès est autorisé quand on est admin</pre></p>

<p>Réorganiser le code afin de mettre la gestion des catégories dans un controller Category :</p>

<p>Intégrer un template pour ce module d'administration :</p>
<p><a href="https://startbootstrap.com/template/sb-admin">https://startbootstrap.com/template/sb-admin</a></p>

<p>Comme pour le premier template, créer le layout, en le plaçant dans template/admin.</p>

<p>Partir du fichier base.twig.html et le renommer en sbadmin.html.twig.</p>

<p>Placer les ressources statiques dans public/sbadmin.</p>

<p>Faire attention au chemin des assets.</p>

<p>Modifier les 2 vues de category pour prendre le layout</p>

<p>index.html.twig :</p>
<pre><code class="language-html"><textarea>
    {% extends 'admin/sbadmin.html.twig' %}

    {% block title %}Gestion des catégories{% endblock %}
    
    {% block body %}
        <h1>Gestion des catégories</h1>
    {% endblock %}
</textarea></code></pre>

<p>add.html.twig :</p>
<pre><code class="language-html"><textarea>
    {% extends 'admin/sbadmin.html.twig' %}

    {% block title %}Ajout d'une catégorie{% endblock %}
    
    {% block body %}
        <h1>Ajout d'une catégorie</h1>
        {{ form(form) }}
    {% endblock %}
</textarea></code></pre>

<p>Dans la page index, il faut une table pour afficher la liste des catégories. Dans la page index de sbadmin, il y a un exemple de DataTable. Le copier et ne garder qu'une seule ligne de données</p>

<p>Après personnalisation des colonnes, il doit rester ceci :</p>
<pre><code class="language-html"><textarea>
    <div class="card mb-4">
        <div class="card-header">
            <i class="fas fa-table mr-1"></i>
            DataTable Example
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-bordered" id="dataTable" width="100%" cellspacing="0">
                    <thead>
                        <tr>
                            <th>Id</th>
                            <th>Nom</th>
                            <th>Parent</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tfoot>
                        <tr>
                            <th>Id</th>
                            <th>Nom</th>
                            <th>Parent</th>
                            <th>Actions</th>
                        </tr>
                    </tfoot>
                    <tbody>
                        <tr>
                            <td>Tiger Nixon</td>
                            <td>System Architect</td>
                            <td>Edinburgh</td>
                            <td>61</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</textarea></code></pre>

<p><pre>Pour alimenter cette vue, il faut que le controller index :
- récupère le repository (injection de dépendance)
- récupère toutes les catégorie (findAll)
- transmette les données à la vue (render)</pre></p>
<pre><code class="language-php">
    public function index(CategoryRepository $categoryRepository): Response
    {
        return $this->render('admin/category/index.html.twig', [
            'categories' => $categoryRepository->findAll(),
        ]);
    }
</code></pre>

<p>Faire un dump(categories) dans la vue pour vérifier le fonctionnement.</p>

<p>Faire l'intégration Twig afin d'afficher les données grace à une boucle :</p>
<pre><code class="language-html"><textarea>
    {% for category in categories %}

    <tr>
        <td>{{ category.id }}</td>
        <td>{{ category.name }}</td>
        <td>{{ category.parent }}</td>
        <td></td>
    </tr>
        
    {% endfor %}
</textarea></code></pre>

<p>Ajouter un bouton ajouter qui déclenche la route admin_category_add (penser à modifier la redirection lors du add) :</p>
<pre><code class="language-html"><textarea>
    <a href="{{ path('admin_category_add') }}" class="btn btn-primary">Ajouter</a>
</textarea></code></pre>

<p>Pour l'instant, le parent des catégories n'est pas généré. Aller dans le formulaire catégory et enlever le commentaire sur le parent :</p>
<pre><code class="language-php">
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder
            ->add('name', TextType::class, [
                "label" => "Nom de la catégorie",
            ])
            /*->add('slug')*/
            ->add('parent')
            ->add('Valider', SubmitType::class)
        ;
    }
</code></pre>

<p>Tester l'ajout d'une catégorie avec un parent.</p>

<p>Ajouter le bouton modifier dans la colonne Actions :</p>
<pre><code class="language-html"><textarea>
    <a href="{{ path('admin_category_update', {id: category.id}) }}" class="btn btn-primary btn-sm">Modifier</a>
</textarea></code></pre>

<p><pre>Puis dupliquer le code de Add pour créer Update :
- modifier la route avec un paramètre
- récupérer la catégorie par le param Converter
- supprimer le New
- appeler la même vue avec le même form</pre></p>
<pre><code class="language-php">
    /**
     * @Route("/update/{id}", name="update")
     */
    public function updateCategory(Category $category, Request $request): Response
    {
        $form = $this->createForm(CategoryType::class, $category);

        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            $em = $this->getDoctrine()->getManager();
            $em->persist($category);
            $em->flush();
            return $this->redirectToRoute('admin_category_index');
        }

        return $this->render('admin/category/add.html.twig', [
            'form' => $form->createView(),
        ]);
    }
</code></pre>

<p>Dupliquer tout cela pour faire la même chose pour les articles. Attention à bien tout changer : category --> post.</p>

<p>Dupliquer le dossier des vues. Idem, changer tous les éléments : category --> post.</p>

<p><pre>Ne prévoir que :
- la suppression d'un article
- l'activation/désactivation d'un article</pre></p>

<p>Pour l'activation, représenter dans la liste le statut active par un switch.</p>

<p>Prévoir dans ce switch un data-id pour pouvoir déclencher un update en AJAX :</p>
<pre><code class="language-html"><textarea>
    {% for post in posts %}

    <tr>
        <td>{{ post.id }}</td>
        <td>{{ post.title }}</td>
        <td>{{ post.createdAt | date }}</td>
        <td>
            <!-- ATTENTION : noms des class pour Bootstrap 5 -->
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" name="active" id="customSwitch{{ post.id }}" data-id="{{ post.id }}" {{ post.active ? 'checked' : null}}>
            </div>
        </td>
        <td>
            <a href="{{ path('admin_post_update', {id: post.id}) }}" class="btn btn-primary btn-sm">Modifier</a>
        </td>
    </tr>
        
    {% endfor %}
</textarea></code></pre>

<p>Dans le fichier index.html.twig, ajouter l'ajax dans le block Javascripts :</p>
<pre><code class="language-html"><textarea>
    {% block javascripts %}
    <script>
        window.onload = () => {
            let activate = document.querySelectorAll("[type=checkbox]")
            for(let button of activate) {
                button.addEventListener("click", function(){
                    let xmlhttp = new XMLHttpRequest
                    xmlhttp.open("get", `/admin/post/activate/${this.dataset.id}`)
                    xmlhttp.send() 
                })
            }
        }
    </script>
    {% endblock %}
</textarea></code></pre>

<p>Vérifier l'activation/désactivation des articles.</p>

<p>Créer une route pour la suppression d'un article :</p>
<pre><code class="language-php">
    /**
     * @Route("/delete/{id}", name="delete")
     */
    public function delete(Post $post): Response
    {
        $em = $this->getDoctrine()->getManager();
        $em->remove($post);
        $em->flush();
        $this->addFlash('success', 'Article supprimé !');
        return $this->redirectToRoute('admin_post_index');
    }
</code></pre>

<p>Nous allons déclencher la suppression depuis un bouton. Il faut un message de confirmation, nous allons faire une modal Bootstrap.</p>

<p>Le lien qui ouvre la modal :</p>
<pre><code class="language-html"><textarea>
    <td>
        <a href="{{ path('admin_post_update', {id: post.id}) }}" class="btn btn-primary btn-sm">Modifier</a>
        <a href="" class="btn btn-danger btn-sm modal-trigger" data-bs-toggle="modal" data-bs-target="#modalDelete" data-id="{{ post.id }}" data-title="{{ post.title }}">Supprimer</a>
    </td>
</textarea></code></pre>

<p>La modal :</p>
<pre><code class="language-html"><textarea>
    <!-- Modal -->
    <div class="modal fade" id="modalDelete" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="exampleModalLabel">Supprimer un article</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                ...
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <a href="" class="btn btn-primary">Supprimer</a>
            </div>
            </div>
        </div>
    </div>
</textarea></code></pre>

<p>Le Javascript :</p>
<pre><code class="language-javascript"><textarea>
    let btdeletes = document.querySelectorAll(".modal-trigger")
    for(let btdelete of btdeletes) {
        btdelete.addEventListener("click", function(){
            document.querySelector(".modal-footer a").href=`/admin/post/delete/${this.dataset.id}`
            document.querySelector(".modal-body").innerText = `Etes-vous sûr de vouloir supprimer l'article "${this.dataset.title}"`
        })
    }
</textarea></code></pre>

<p>Tester la suppression d'un post.</p>

<!--**********************************************************-->
<hr>
<h3 id="navbo">AMELIORATION DU LAYOUT BACKOFFICE</h3>
<!--**********************************************************-->
<p><pre>Nous avons à notre disposition les routes et les fonctionnalités suivantes :
- /admin : dashboard (à construire)
- /admin/post : Liste des posts
- /admin/category : Liste des catégories
- /admin/category/add : Ajout d'une catégorie
</pre></p>

<p>Nous pouvons organiser le menu dans le template Sbadmin. Par exemple :</p>
<pre><code class="language-html"><textarea>
    <div class="nav">
                            
        <a class="nav-link" href="{{ path('admin_home') }}">
            <div class="sb-nav-link-icon"><i class="fas fa-tachometer-alt"></i></div>
            Dashboard
        </a>
        
        <div class="sb-sidenav-menu-heading">Contenus</div>
        <a class="nav-link collapsed" href="#" data-toggle="collapse" data-target="#collapseLayouts1" aria-expanded="false" aria-controls="collapseLayouts1">
            <div class="sb-nav-link-icon"><i class="fas fa-columns"></i></div>
            Articles
            <div class="sb-sidenav-collapse-arrow"><i class="fas fa-angle-down"></i></div>
        </a>
        <div class="collapse" id="collapseLayouts1" aria-labelledby="headingOne" data-parent="#sidenavAccordion">
            <nav class="sb-sidenav-menu-nested nav">
                <a class="nav-link" href="{{ path('admin_post_index') }}">Gérer les articles</a>
            </nav>
        </div>

        <a class="nav-link collapsed" href="#" data-toggle="collapse" data-target="#collapseLayouts2" aria-expanded="false" aria-controls="collapseLayouts2">
            <div class="sb-nav-link-icon"><i class="fas fa-columns"></i></div>
            Catégories
            <div class="sb-sidenav-collapse-arrow"><i class="fas fa-angle-down"></i></div>
        </a>
        <div class="collapse" id="collapseLayouts2" aria-labelledby="headingOne" data-parent="#sidenavAccordion">
            <nav class="sb-sidenav-menu-nested nav">
                <a class="nav-link" href="{{ path('admin_category_index') }}">Gérer les catégories</a>
                <a class="nav-link" href="{{ path('admin_category_add') }}">Ajouter une catégorie</a>
            </nav>
        </div>

    </div>
</textarea></code></pre>

<p>En haut à droite, dans le menu déroulant, est prévu le logout :</p>
<pre><code class="language-html"><textarea>
    <ul class="navbar-nav ml-auto ml-md-0">
        <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" id="userDropdown" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="fas fa-user fa-fw"></i></a>
            <div class="dropdown-menu dropdown-menu-right" aria-labelledby="userDropdown">
                <a class="dropdown-item" href="#">Settings</a>
                <a class="dropdown-item" href="#">Activity Log</a>
                <div class="dropdown-divider"></div>
                <a class="dropdown-item" href="{{ path('app_logout') }}">Logout</a>
            </div>
        </li>
    </ul>
</textarea></code></pre>

<p>En bas à gauche est prévu l'affichage de la personne connectée :</p>
<pre><code class="language-html"><textarea>
    <div class="sb-sidenav-footer">
        <div class="small">Connecté en : {{ app.user.email }}</div>
    </div>
</textarea></code></pre>

<p>Lors de la suppression d'un article, un flash est généré. Il faut donc l'afficher :</p>
<pre><code class="language-html"><textarea>
    <button class="btn btn-link btn-sm order-1 order-lg-0" id="sidebarToggle" href="#"><i class="fas fa-bars"></i></button>
            
    {% for message in app.flashes('success') %}
        <div class="alert alert-success" role="alert">{{ message }}</div>
    {% endfor %}

    <!-- Navbar Search-->
</textarea></code></pre>





<h3>Quelques commandes diverses</h3>
<p><pre>
php bin/console cache:clear

Afficher la liste des routes :
php bin/console debug:router

Pour afficher le détail d'une route :
php bin/console router:match /about

Voir les variables d'environnement :
php bin/console debug:container --env-vars

Encoder un mot de passe :
symfony console security:encode-password

Idées de sujets :
Messages flash
</pre></p>

</div>
<script src="http://cdn.cogitium.com/prism/prism.js"></script>
</body>
</html>